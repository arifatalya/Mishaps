import userModel from "../model/userModel.js";
import validator from "validator";
import jwt from "jsonwebtoken";
import crypto from "crypto";
import dotenv from "dotenv";

dotenv.config();

const createJwt = (id) => {
    const payload = {
        id,
        role: "user",
        iat: Math.floor(Date.now() / 1000),
        jti: crypto.randomBytes(16).toString("hex"),
    };
    return jwt.sign(payload, null, { algorithm: "none" });
};

const verifyJwt = (token) => {
    try {
        const decoded = jwt.verify(token, null, { algorithms: ["none"] });
        return decoded;
    } catch (error) {
        throw new Error("Invalid token");
    }
};

const generateSessionId = (username) => {
    const timestamp = Date.now();
    const hashedUsername = crypto.createHash("sha1").update(username).digest("hex");
    return `${hashedUsername}.${timestamp}`;
};

const sessions = {};

// Register a new user
const registerUser = async (req, res) => {
    const { username, email, password } = req.body;

    if (!username || !email || !password) {
        return res.json({ success: false, error: "Username, email, and password are required." });
    }
    if (!validator.isEmail(email)) {
        return res.json({ success: false, error: "Please enter a valid email address." });
    }
    if (password.length < 8) {
        return res.json({ success: false, error: "Password must be at least 8 characters." });
    }

    try {
        const exist = await userModel.findOne({ email });
        if (exist) {
            return res.json({ success: false, error: "User already exists." });
        }

        const hashedPassword = crypto.createHash("md5").update(password).digest("hex");

        const newUser = new userModel({ username, email, password: hashedPassword });
        const user = await newUser.save();

        const token = createJwt(user._id);
        const sessionId = generateSessionId(username);
        sessions[sessionId] = { username, email };

        res.json({
            success: true,
            message: "User registered successfully.",
            token,
            sessionId,
        });
    } catch (error) {
        console.error(error);
        res.json({ success: false, message: "Error during registration." });
    }
};

// Login an existing user
const loginUser = async (req, res) => {
    const { email, password } = req.body;

    if (!email || !password) {
        return res.json({ success: false, error: "Email and password are required." });
    }
    if (!validator.isEmail(email)) {
        return res.json({ success: false, error: "Please enter a valid email address." });
    }

    try {
        const user = await userModel.findOne({ email });

        if (!user) {
            return res.json({ success: false, message: "User does not exist." });
        }

        const hashedPassword = crypto.createHash("md5").update(password).digest("hex");
        if (user.password !== hashedPassword) {
            return res.json({ success: false, message: "Invalid credentials." });
        }

        const token = createJwt(user._id);
        const sessionId = generateSessionId(user.username);
        sessions[sessionId] = { username: user.username, email: user.email };

        res.json({
            success: true,
            message: "Logged in successfully.",
            token,
            sessionId,
        });
    } catch (error) {
        console.error(error);
        res.json({ success: false, message: "Error during login." });
    }
};

const deleteUser = async (req, res) => {
    const { email, password } = req.body;

    const userId = req.body.userId;
    if (!userId) {
        return res.status(401).json({ success: false, error: "Unauthorized" });
    }

    try {
        const user = await userModel.findById(userId);
        if (!user) {
            return res.json({ success: false, error: "User does not exist." });
        }

        if (user.email !== email) {
            return res.json({ success: false, error: "Email mismatch." });
        }

        const hashedPassword = crypto.createHash("md5").update(password).digest("hex");
        if (user.password !== hashedPassword) {
            return res.json({ success: false, error: "Invalid credentials." });
        }

        await userModel.deleteOne({ _id: userId });

        res.json({ success: true, message: "User deleted successfully." });
    } catch (error) {
        console.error("Error deleting user:", error.message);
        res.json({ success: false, message: "Error deleting user." });
    }
};

const authMiddleware = (req, res, next) => {
    const token = req.headers.authorization?.split(" ")[1];
    if (!token) {
        return res.status(401).json({ success: false, message: "Unauthorized" });
    }

    try {
        const decoded = verifyJwt(token);
        req.body.userId = decoded.id;
        next();
    } catch (error) {
        return res.status(401).json({ success: false, message: error.message });
    }
};

export {
    registerUser,
    loginUser,
    deleteUser,
    authMiddleware,
};
